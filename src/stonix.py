#!/usr/bin/env python3
###############################################################################
#                                                                             #
# Copyright 2019. Triad National Security, LLC. All rights reserved.          #
# This program was produced under U.S. Government contract 89233218CNA000001  #
# for Los Alamos National Laboratory (LANL), which is operated by Triad       #
# National Security, LLC for the U.S. Department of Energy/National Nuclear   #
# Security Administration.                                                    #
#                                                                             #
# All rights in the program are reserved by Triad National Security, LLC, and #
# the U.S. Department of Energy/National Nuclear Security Administration. The #
# Government is granted for itself and others acting on its behalf a          #
# nonexclusive, paid-up, irrevocable worldwide license in this material to    #
# reproduce, prepare derivative works, distribute copies to the public,       #
# perform publicly and display publicly, and to permit others to do so.       #
#                                                                             #
###############################################################################




# =========================================================================== #
#               Filename          $RCSfile: stonix/stonix_resources.py,v $
#               Description       Security Configuration Script
#               OS                Linux, Mac OS X, Solaris, BSD
#               Author            Dave Kennel
#               Last updated by   $Author: $
#               Notes             Based on CIS Benchmarks, NSA RHEL
#                                 Guidelines, NIST and DISA STIG/Checklist
#               Release           $Revision: 1.0 $
#               Modified Date     $Date: 2010/8/23 14:00:00 $
# =========================================================================== #

############################################################################
#
# stonix - The Security Tool For Unix
#
# This program is designed to harden and configure multiple Unix-like operating
# systems.
#
# This script is installed by the LANL-stonix package if installed from the
# native package format.
# This script will configure the machine to the LANL "standard" as
# defined by the LANL *NIX Configuration Guideline.
#
# It is intended to complete the hardening of Unix-like systems,
# based on the CIS Linux Benchmarks, NSA, or NIST guidance.  The program
# will be evaluated / updated as newer versions of the guidance documents are
# released.
#
# The operation of this program may be tuned by modifying the
# /usr/local/etc/stonix_resources.conf file.
# See the comments in that file for instructions.
#
# Programmer notes:
# All functions and classes shall have pydoc documentation.
# Do not trust input from any source.
# Whenever applicable unit tests using pyunit will be created.
# In all other cases code must be self testing.
# Code should be written to PEP 8 and be checked with pylint.
# Code autogenerated by QT Designer is excepted from the PEP 8 and pylint
# requirements.
# Only use from <module> import <item> when including base classes
# all other imports and usages should stay in independent name spaces.
#

############################################################################
#
# Changelog
#
# 2010-08-23
# - Revision 1.0

"""%prog [options]

Apply security hardening settings according to LANL guidelines.

The following options control the running of the script:
 -f  --fix  Apply system hardening.
 -r  --report  Print a configuration compliance report.
 -G  Use the GUI interface (default option)
 -c  --cli  Use the Console interface.
 -X  --rollback  Will rollback file changes to pre-STONIX state.
 -h  --help  or no arguments will display this help message and exit.
 -v  --verbose print verbose information about what stor is doing.
 -m --module modulename run a single stonix rule. Requires -f, -X or -r.
 -p --printconfigsimple
      Generate a new config file with current options in the simple format.
 -P --printconfigfull
      Generate a new config file with current options in the full format (shows all options).
 -l --list
      Print the list of installed rules that apply to this platform.

WARNING! If run with the -f flag THIS PROGRAM WILL MODIFY
SYSTEM SETTINGS!

*********
Some changes applied by STONIX require the system to be rebooted
to take effect
*********

STONIX is a system hardening program produced by the NIE
Development Services team. It is designed to apply hardening settings
to Unix and Unix-like operating systems in accordance with published
security guidelines.

When run with the -f flag the script will apply configuration changes
designed to reduce the attack surface of the system. In all possible
cases the original files will be backed up at
/usr/local/share/stonix/backups and marked with a .ovf for Original
Vendor File. All system changes will also be logged to
/var/log/stonix-info. If you are unfamiliar with the
hardening process please review the hardening guidance from CIS, DISA and NSA.

Created on Aug 23, 2010


@change: 2017/03/07 - David Kennel - Added support for FISMA categorization.
@change: 2017/06/19 - David Kennel - Added safeties to rule loading for redundant
        rule names and numbers.
@change: 2017/07/12 - Breen Malmberg - added method getruleauditonly();
        added to do notes; changed author name formats to be consistent;
        fixed some typo's in the class doc string; updated group name (CSD -> NIE)
@change: 2019/04/08 - Breen Malmberg - removed unused import 'imp'; fixed unreachable logging calls
"""

import sys
import os
import re
import stat
import traceback
import time
import subprocess
from pkgutil import extend_path

# Local imports
__path__ = extend_path(os.path.dirname(os.path.abspath(__file__)), 'stonix_resources')

from stonix_resources.observable import Observable
from stonix_resources.configuration import Configuration
from stonix_resources.environment import Environment
from stonix_resources.StateChgLogger import StateChgLogger
from stonix_resources.logdispatcher import LogPriority, LogDispatcher
from stonix_resources.program_arguments import ProgramArguments
from stonix_resources.CommandHelper import CommandHelper
from stonix_resources.cli import Cli


class Controller(Observable):
    """This is the main worker object for stonix. It handles the
    stand up and tear down of the rest of the program.

    """

    def __init__(self):
        """

        """

        Observable.__init__(self)
        self.environ = Environment()
        self.mode = "gui"
        self.fix = False
        self.report = False
        self.undo = False
        self.runrule = None
        self.pcf = False
        self.pcs = False
        self.list = False

        self.euid = self.environ.geteuid()
        test_mode = self.environ.get_test_mode()
        self.lockfile = '/var/run/stonix.pid'
        self.config = Configuration(self.environ)
        self.numrulesrunning = 0
        self.numrulescomplete = 0
        self.currulename = ''
        self.currulenum = 0

        # this part added so stonix will create files with the intended root umask (022)
        # instead of using the default user umask (which is currently being set to 077)
        # running stonix with a umask of 077 would break several bits of functionality
        # (namely installbanners, in some cases)
        if self.euid == 0:
            os.umask(0o22)

        if test_mode:
            self.setuptesting()
        if not self.mode == 'test':
            # processargs() MUST be called BEFORE logging object is instantiated to
            # get the given logging level provided via command line!
            self.prog_args = ProgramArguments()
            self.processargs()

        self.logger = LogDispatcher(self.environ)
        self.logger.log(LogPriority.DEBUG, 'Logging Started')
        self.ch = CommandHelper(self.logger)
        self.statechglogger = StateChgLogger(self.logger, self.environ)
        self.logger.log(LogPriority.DEBUG, 'State Logger Started')

        if not self.safetycheck():
            self.logger.log(LogPriority.CRITICAL, ['SafetyCheck', 'ERROR: Installation safety check failed!'])
            self.logger.log(LogPriority.WARNING, ['SafetyCheck', 'STONIX will now exit.'])
            sys.exit(1)

        try:
            fismacategory = self.config.getconfvalue('main', 'fismacat')
            self.environ.setsystemfismacat(fismacategory)
        except KeyError:
            pass

        # set session variables needed by stonix which may not normally get
        # set when running under a root context
        self.setup_session_vars()

        self.tryacquirelock()

        try:

            if self.mode == "gui":

                try:
                    from PyQt5 import QtCore, QtWidgets, QtGui
                    from stonix_resources.gui_pyqt5 import GUI
                    self.logger.log(LogPriority.DEBUG, "Using PyQt5 libraries")
                except:
                    self.logger.log(LogPriority.DEBUG, "PyQt5 libraries not found")
                    from PyQt4 import QtCore, QtGui
                    from stonix_resources.gui import GUI
                    self.logger.log(LogPriority.DEBUG, "Using PyQt4 libraries")

                icon_path = self.environ.get_icon_path()

                if "PyQt5" in sys.modules:
                    app = QtWidgets.QApplication(sys.argv)
                    splashart = os.path.join(icon_path, 'StonixSplash.png')
                    splashimage = QtGui.QPixmap(splashart)
                    splash = QtWidgets.QSplashScreen(splashimage, QtCore.Qt.WindowStaysOnTopHint)
                    splash.setMask(splashimage.mask())
                    splash.show()
                    app.processEvents()
                elif "PyQt4" in sys.modules:
                    app = QtGui.QApplication(sys.argv)
                    splashart = os.path.join(icon_path, 'StonixSplash.png')
                    splashimage = QtGui.QPixmap(splashart)
                    splash = QtGui.QSplashScreen(splashimage, QtCore.Qt.WindowStaysOnTopHint)
                    splash.setMask(splashimage.mask())
                    splash.show()
                    app.processEvents()
                else:
                    self.mode = "cli"
                    self.logger.log(LogPriority.DEBUG, "Unable to detect PyQt5 or PyQt4 libraries. Reverting to command line mode")

                # NB We don't have a main event loop at this point so we call
                # the app.processEvents() again to make the splash screen show
                if self.mode == "gui":
                    app.processEvents()

        except Exception as err:
            self.logger.log(LogPriority.DEBUG, str(err))
            self.mode = "cli"

        self.logger.log(LogPriority.DEBUG, 'Running in ' + self.mode)

        starttime = time.time()
        allrules = self.getrules(self.config, self.environ)
        etime = time.time() - starttime
        self.logger.log(LogPriority.DEBUG, 'Rules Processed in ' + str(etime))
        self.installedrules = self.findapplicable(allrules)

        # if no applicable rules are found, exit STONIX with message
        if len(self.installedrules) == 0:
            try:
                self.releaselock()
            except:
                pass
            sys.exit("********************\n\nSTONIX: No applicable rules for this platform\n\n********************")

        etime = time.time() - starttime
        self.logger.log(LogPriority.DEBUG, 'Rules Applicable in ' + str(etime))
        self.numexecutingrules = len(self.installedrules)
        self.environ.setnumrules(self.numexecutingrules)
        self.logger.logRuleCount()
        self.logger.log(LogPriority.DEBUG, str(self.numexecutingrules) + ' rules loaded')
        self.logger.log(LogPriority.DEBUG, ['CurrentEUID', str(self.environ.geteuid())])
        self.logger.log(LogPriority.DEBUG, ['OSFamily', self.environ.getosfamily()])
        self.logger.log(LogPriority.DEBUG, ['OSType', self.environ.getostype()])
        self.logger.log(LogPriority.DEBUG, ['OSVersion', self.environ.getosver()])
        self.list = self.prog_args.getList()

        if self.list:
            self.__listrules()
        elif self.mode == 'cli':
            self.__clirun()
        elif self.mode == 'gui':
            myui = GUI(self, self.environ, self.logger)
            splash.finish(myui)
            sys.exit(app.exec_())
        elif self.mode == 'test':
            pass

    def setup_session_vars(self):
        """

        """

        session_vars_dict = {"DBUS_SESSION_BUS_ADDRESS": "export $(dbus-launch)"}

        try:
            for sv in session_vars_dict:
                self.set_session_var(sv, session_vars_dict[sv])
        except:
            self.logger.log(LogPriority.WARNING, "Unable to set " + sv + " session variable")
            pass

    def set_session_var(self, session_var, set_command):
        """

        :param session_var: session variable to set
        :param set_command: the command to run to set the given session variable

        """

        session_var_value = ""

        try:
            session_var_value = os.environ[session_var]
        except KeyError:
            pass

        try:
            if not session_var_value:
                self.ch.executeCommand(set_command)
        except:
            raise

    def getrules(self, config, environ):
        """Private method to process the stonix rules file to populate the rules.

        :param config: Configuration object instance
        :param environ: Environment object instance
        :return: instruleclasses
        :rtype: list ;  List of instantiated rule objects

        """
        rulewalklist = []
        instruleclasses = []
        validrulefiles = []
        rulenumbers = []
        rulenames = []
        initlist = ['__init__.py', '__init__.pyc', '__init__.pyo']

        stonixPath = self.environ.get_resources_path()
        self.logger.log(LogPriority.DEBUG,
                        ['STONIX Path:', str(stonixPath)])
        rulesPath = self.environ.get_rules_path()
        self.logger.log(LogPriority.DEBUG,
                        ['Rules Path:', str(rulesPath)])

        sys.path.append(stonixPath)
        sys.path.append(rulesPath)

        for path in sys.path:
            self.logger.log(LogPriority.DEBUG,
                            ['Sys Path Element:', str(path)])

        rulefiles = os.listdir(str(rulesPath))

        #####
        # Check if stonix has been 'frozen' with pyinstaller, py2app, etc and
        # process rules accordingly
        if hasattr(sys, 'frozen'):
            #####
            # Search through the already imported libraries for stonix rules
            for item in list(sys.modules.keys()):
                if re.match("stonix_resources\.rules\.[A-Z]\w+$", item):
                    self.logger.log(LogPriority.DEBUG,
                                    'Key Match: ' + str(item))
                    rulewalklist.append(item)
            self.logger.log(LogPriority.DEBUG,
                            ['Rule Walk list from keys: ', str(rulewalklist)])
        else:
            for rfile in rulefiles:
                if rfile in initlist:
                    continue
                else:
                    validrulefiles.append(rfile)
            self.logger.log(LogPriority.DEBUG,
                            ['validrulefiles: ', str(rulewalklist)])
            # This is a list comprehension to build a list of module names to
            # import based on the names of valid rule files from stonix/rules
            # destination list = [ *transform* *source* *filter* ]
            modulenames = [mod.replace('.py', '') for mod in validrulefiles
                            if re.search("\.py$", mod)]
            self.logger.log(LogPriority.DEBUG,
                            ['Module names:', str(modulenames)])

            # The output of this section is a list of valid, fully qualified,
            # rule class names.
            for module in modulenames:
                module = module.split("/")[-1]

                classname = 'stonix_resources.rules.' + module + '.' + module
                rulewalklist.append(classname)

        self.logger.log(LogPriority.DEBUG,
                        ['Walk list:', str(rulewalklist)])

        for rule in rulewalklist:
            if hasattr(sys, 'frozen'):
                starttime = time.time()
                #####
                # Make sure rules start with a letter...
                self.logger.log(LogPriority.DEBUG,
                                'Using Frozen path for ' + str(rule))
                #####
                # Get just the rule name
                ruleClass = rule.split('.')[2]
                self.logger.log(LogPriority.DEBUG,
                                'Class name after split: ' + str(ruleClass))
                #####
                # Acquire the rule class module
                mod = getattr(sys.modules[rule], ruleClass)
                self.logger.log(LogPriority.DEBUG,
                                'Mod name: ' + str(mod))
            else:
                # This is odd and requires detailed comments. This block imports the
                # modules then recurses down, instantiates the main rule class and
                # appends the class to a list.
                starttime = time.time()
                parts = rule.split(".")
                # the module is the class less the last element
                module = ".".join(parts[:-1])
                # Using the __import__ built in function to import the module
                # since our names are only known at runtime.
                self.logger.log(LogPriority.DEBUG,
                                'Attempting to load: ' + str(module))
                try:
                    mod = __import__(module)
                except Exception:
                    trace = traceback.format_exc()
                    self.logger.log(LogPriority.ERROR,
                                    "Error importing rule: " + trace)
                    continue
                # Recurse down the class name until we get a reference to the 
                # class itself. Then we instantiate using the reference.
                for component in parts[1:]:
                    try:
                        mod = getattr(mod, component)
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR,
                                        "Error finding rule class reference: "
                                        + str(trace))
                        continue
            try:
                clinst = mod(config, environ,
                             self.logger,
                             self.statechglogger)
                rulenum = clinst.getrulenum()
                self.logger.log(LogPriority.DEBUG,
                                'Checking Rule Number: ' + str(rulenum))
                rulename = clinst.getrulename()
                self.logger.log(LogPriority.DEBUG,
                                'Checking Rule Name: ' + str(rulename))
                if rulenum in rulenumbers:
                    self.logger.log(LogPriority.DEBUG, 'Rule Numbers List: ' + str(rulenumbers))
                    raise ValueError('ERROR: Rule Number ' + str(rulenum) + ' already instantiated! Not loading rule: ' + rulename)
                elif rulename in rulenames:
                    self.logger.log(LogPriority.DEBUG, 'Rule Numbers List: ' + str(rulenames))
                    raise ValueError('ERROR: Rule ' + rulename + ' already instantiated! Not loading rule: ' + str(rulenum))
                else:
                    rulenumbers.append(rulenum)
                    rulenames.append(rulename)
                    instruleclasses.append(clinst)
                etime = time.time() - starttime
                self.logger.log(LogPriority.DEBUG,
                                'load time: ' + str(etime))
            except (KeyboardInterrupt, SystemExit):
                # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR,
                                "Error instantiating rule: " + str(trace))
                continue

        return instruleclasses

    def findapplicable(self, rules):
        """This method checks each rule to see if it is applicable on the current
        platform on which stonix is running. A list of applicable rule objects
        is returned.

        :param rules: List of instantiated rule objects
        :return: List of instantiated rule objects
        

        """
        applicablerules = []
        for rule in rules:
            try:
                if rule.isapplicable():
                    self.logger.log(LogPriority.DEBUG,
                                    'Rule is applicable by platform ' +
                                    ' EUID: ' + str(self.environ.geteuid()) +
                                    ' Root required: ' +
                                    str(rule.getisrootrequired()))
                    if self.environ.geteuid() != 0 and rule.getisrootrequired():
                        self.logger.log(LogPriority.DEBUG,
                                    'Skipping ' + rule.getrulename() +
                                    ' root required.')
                    else:
                        self.logger.log(LogPriority.DEBUG,
                                    'Adding ' + rule.getrulename() +
                                    ' to run list.')
                        applicablerules.append(rule)
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR,
                                "Error determining rule applicability: "
                                + trace)
        return applicablerules

    def getallrulesdata(self):
        """This method returns a dictionary of lists containing the data for all
        installed rules. Returned properties include; rule name, rule number,
        and the rule help text. The dictionary is keyed by rule number.


        :return: Dictionary of lists
        

        """
        rulesdata = {}
        for rule in self.installedrules:
            rulenum = rule.getrulenum()
            rulename = rule.getrulename()
            ruletxt = rule.gethelptext()
            ruledetails = [rulename, ruletxt]
            rulesdata[rulenum] = ruledetails
        return rulesdata

    def getrulenumbyname(self, name):
        """This method takes a name associated with a rule as an argument and
        translates it into a number associated with a rule class. Acceptable
        rule names are the section headers from the stonix_resources.conf.
        These section headers are generated from the rulename property that
        each rule has.

        :param string name: of the rule to fetch a number for.
        :return: rulenum
        :rtype: int
        """

        rulenum = 0
        for rule in self.installedrules:
            rulename = rule.getrulename()
            if rulename == name:
                rulenum = rule.getrulenum()
        return rulenum

    def getrulenamebynum(self, rulenum):
        """This method takes a number associated with a rule as an argument and
        translates it into a name associated with a rule class. Acceptable
        rule number are integers and are found in rule implementations.

        :param int rulenum: of the rule to fetch a name for.
        :return: rulename
        :rtype: str
        

        """

        rulename = ""
        for rule in self.installedrules:
            ruleid = rule.getrulenum()
            if rulenum == ruleid:
                rulename = rule.getrulename()
        return rulename

    def hardensystem(self):
        """Call all rules in fix(harden) mode


        
        """
        self.numrulesrunning = self.numexecutingrules
        self.numrulescomplete = 0
        for rule in self.installedrules:
            self.currulenum = rule.getrulenum()
            self.currulename = rule.getrulename()
            try:
                self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(self.currulename) + " ******************")
                starttime = time.time()
                self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                rule.report()
                self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                if not rule.getrulesuccess():
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(),
                                     rule.getdetailedresults()])
                elif not rule.iscompliant():
                    self.logger.log(LogPriority.DEBUG, "=================== START FIX ===================")
                    rule.fix()
                    self.logger.log(LogPriority.DEBUG, "==================== END FIX ====================")
                    if rule.getrulesuccess():
                        self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                        rule.report()
                        self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                        if not rule.getrulesuccess():
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                             rule.getdetailedresults()])
                        elif not rule.iscompliant():
                            self.logger.log(LogPriority.WARNING,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                        else:
                            self.logger.log(LogPriority.INFO,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                else:
                    self.logger.log(LogPriority.INFO,
                                    [rule.getrulename(),
                                    rule.getdetailedresults()])
                etime = time.time() - starttime
                self.logger.log(LogPriority.DEBUG,
                                [rule.getrulename(),
                                'Elapsed Time: ' + str(etime)])
                self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(self.currulename) + " ******************")
            except (KeyboardInterrupt, SystemExit):
            # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR, [rule.getrulename(),
                                "Controller caught rule death: "
                                + trace])
            self.numrulescomplete = self.numrulescomplete + 1
            self.set_dirty()
            self.notify_check()

    def auditsystem(self):
        """Call all rules in audit(report) mode

        """
        self.numrulesrunning = self.numexecutingrules
        self.numrulescomplete = 0
        for rule in self.installedrules:
            self.currulenum = rule.getrulenum()
            self.currulename = rule.getrulename()
            try:
                self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(self.currulename) + " ******************")
                starttime = time.time()
                self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                rule.report()
                self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                etime = time.time() - starttime
                self.logger.log(LogPriority.DEBUG,
                                [rule.getrulename(),
                                'Elapsed Time: ' + str(etime)])
                self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(self.currulename) + " ******************")
            except (KeyboardInterrupt, SystemExit):
                # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR, [rule.getrulename(),
                                "Controller caught rule death: "
                                + trace])
            self.numrulescomplete = self.numrulescomplete + 1
            if not rule.getrulesuccess():
                self.logger.log(LogPriority.ERROR,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            if not rule.iscompliant():
                self.logger.log(LogPriority.WARNING,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            else:
                self.logger.log(LogPriority.INFO,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            self.set_dirty()
            self.notify_check()

    def runruleharden(self, ruleid):
        """Run a single rule in fix(harden) mode

        :param int ruleid:

        """
        self.numrulesrunning = 1
        self.numrulescomplete = 0
        rulename = self.getrulenamebynum(ruleid)
        self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(rulename) + " ******************")
        self.logger.log(LogPriority.DEBUG, ['RunRuleHarden',
                         'Attempting to run ' + str(ruleid)])

        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                if rule.getisrootrequired() and self.environ.geteuid() != 0:
                    self.numrulescomplete = self.numrulescomplete + 1
                    message = "Could not run rule: insufficient privilege level"
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(), message])
                else:
                    starttime = time.time()
                    try:
                        self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                        rule.report()
                        self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                    except (KeyboardInterrupt, SystemExit):
                        # User initiated exit
                        raise
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR, [rule.getrulename(),
                                        "Controller caught rule death: "
                                        + trace])
                    if not rule.getrulesuccess():
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                        self.logger.log(LogPriority.INFO,
                                        [rule.getrulename(),
                                         'Rule failed: Rule config in unknown state. Skipping rule'])
                        self.numrulescomplete = self.numrulescomplete + 1
                    elif not rule.iscompliant():
                        try:
                            self.logger.log(LogPriority.DEBUG, "=================== START FIX ===================")
                            rule.fix()
                            self.logger.log(LogPriority.DEBUG, "==================== END FIX ====================")
                        except (KeyboardInterrupt, SystemExit):
                            # User initiated exit
                            raise
                        except Exception:
                            trace = traceback.format_exc()
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                            "Controller caught rule death: "
                                            + trace])
                        if not rule.getrulesuccess():
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                             rule.getdetailedresults()])
                        try:
                            self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                            rule.report()
                            self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                        except (KeyboardInterrupt, SystemExit):
                            # User initiated exit
                            raise
                        except Exception:
                            trace = traceback.format_exc()
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                             "Controller caught rule death: "
                                            + trace])
                        if not rule.iscompliant():
                            self.logger.log(LogPriority.WARNING,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                        else:
                            self.logger.log(LogPriority.INFO,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                    self.numrulescomplete = self.numrulescomplete + 1
                    etime = time.time() - starttime
                    self.logger.log(LogPriority.DEBUG,
                                    [rule.getrulename(),
                                     'Elapsed Time: ' + str(etime)])
                    self.set_dirty()
                    self.notify_check()
        if self.numrulescomplete == 0:
            message = "Could not find rule! Searched for ruleid = " \
            + str(ruleid)
            self.logger.log(LogPriority.ERROR,
                            message)
        self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(rulename) + " ******************")

    def runruleaudit(self, ruleid):
        """Run a single rule in audit(report) mode

        :param int ruleid:

        """
        rulename = self.getrulenamebynum(ruleid)
        self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(rulename) + " ******************")
        message = "Controller:runruleaudit: Entering rule with id " + \
        str(ruleid)
        self.logger.log(LogPriority.DEBUG, message)
        self.numrulesrunning = 1
        self.numrulescomplete = 0
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                message = "Controller:runruleaudit: Matched rule id"
                self.logger.log(LogPriority.DEBUG, message)
                if rule.getisrootrequired() and self.environ.geteuid() != 0:
                    self.numrulescomplete = self.numrulescomplete + 1
                    message = "Could not run rule: insufficient privilege level"
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(), message])
                else:
                    starttime = time.time()
                    try:
                        self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                        rule.report()
                        self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                    except (KeyboardInterrupt, SystemExit):
                        # User initiated exit
                        raise
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        "Controller caught rule death: "
                                        + trace])
                    self.numrulescomplete = self.numrulescomplete + 1
                    if not rule.getrulesuccess():
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    if not rule.iscompliant():
                        self.logger.log(LogPriority.WARNING,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    else:
                        self.logger.log(LogPriority.INFO,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    etime = time.time() - starttime
                    self.logger.log(LogPriority.DEBUG,
                                    [rule.getrulename(),
                                     'Elapsed Time: ' + str(etime)])
                    self.set_dirty()
                    self.notify_check()
        self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(rulename) + " ******************")

    def undochangessystem(self):
        """Undo all changes to the system.

        """
        self.numrulesrunning = self.numexecutingrules
        self.numrulescomplete = 0
        for rule in self.installedrules:
            self.currulenum = rule.getrulenum()
            self.currulename = rule.getrulename()
            try:
                rule.undo()
            except (KeyboardInterrupt, SystemExit):
                # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR,
                                [rule.getrulename(),
                                "Controller caught rule death: "
                                + trace])
            self.numrulescomplete = self.numrulescomplete + 1
            if not rule.getrulesuccess():
                self.logger.log(LogPriority.ERROR,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            else:
                self.logger.log(LogPriority.INFO,
                                [rule.getrulename(),
                                 rule.getdetailedresults()])
            self.set_dirty()
            self.notify_check()

    def undorule(self, ruleid):
        """Undo the changes from a single rule. Expects the integer rule number
        as the ruleid

        :param int ruleid:

        """
        self.numrulesrunning = 1
        self.numrulescomplete = 0
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                if rule.getisrootrequired() and self.environ.geteuid() != 0:
                    self.numrulescomplete = self.numrulescomplete + 1
                    message = "Could not run rule: insufficient privilege level"
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(), message])
                else:
                    try:
                        rule.undo()
                    except (KeyboardInterrupt, SystemExit):
                        # User initiated exit
                        raise
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        "Controller caught rule death: "
                                        + trace])
                    self.numrulescomplete = self.numrulescomplete + 1
                    if not rule.getrulesuccess():
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    else:
                        self.logger.log(LogPriority.INFO,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    self.set_dirty()
                    self.notify_check()

    def getrulehelp(self, ruleid):
        """Return rule help information.

        :param int ruleid: int (identifier) of rule to get help text for.
        :return: helptxt
        :rtype: str
        
        """
        helptxt = ""
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                helptxt = rule.gethelptext()
        return helptxt

    def updatedbs(self):
        """Update all databases held by database rules in stonix_resources.

        """
        numdbrules = 0
        self.numrulescomplete = 0
        for rule in self.installedrules:
            if rule.isdatabaserule():
                numdbrules = numdbrules + 1
        self.numrulesrunning = numdbrules
        for rule in self.installedrules:
            if rule.isdatabaserule():
                self.currulenum = rule.getrulenum()
                self.currulename = rule.getrulename()
                try:
                    self.logger.log(LogPriority.DEBUG, "=================== START FIX ===================")
                    rule.fix()
                    self.logger.log(LogPriority.DEBUG, "==================== END FIX ====================")
                except (KeyboardInterrupt, SystemExit):
                    # User initiated exit
                    raise
                except Exception:
                    trace = traceback.format_exc()
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(),
                                    "Controller caught rule death: "
                                    + trace])
                self.numrulescomplete = self.numrulescomplete + 1
                self.set_dirty()
                self.notify_check()

    def getconfigoptions(self):
        """This method retrieves the configitems for all rules and returns a dict
        of lists where the keys are rule names and the lists contain the rule
        text and a list of configitem objects for that rule.

        :return: configdict
        :rtype: dict
        
        """
        configdict = {}
        for rule in self.installedrules:
            rulename = rule.getrulename()
            ruledata = [rule.gethelptext()]
            for configitem in rule.getconfigitems():
                ruledata.append(configitem)
            configdict[rulename] = ruledata

        return configdict

    def getruleconfigoptions(self, ruleid):
        """This method returns the configurationitem object instances associated
        with a rule. We expect to be passed the integer rule number to id the
        rule.

        :param int ruleid: Integer rule number
        :return: cilist
        :rtype: list
        
        """
        cilist = []
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                cilist = rule.getconfigitems()
        return cilist

    def regenerateconfig(self, simpleconf):
        """This method will write the stonix configuration file with the current
        configuration data. If simpleconf is True then we only write changed
        rules and rules that are marked as being in the simple config.
        
        The configuration file object actually does most of the work here.

        :param bool simpleconf: Whether or not we are generating a simple
        configuration file or not.
                
        """
        currdata = self.getconfigoptions()
        self.config.writeconfig(simpleconf, currdata)

    def getcurrentrule(self):
        """This method returns the rule name for the currently executing rule.
        This method only returns valid data when called while the whole rule
        stack is running.


        :return: string : rulename
        
        """
        return self.currulename

    def getrulecompstatus(self, ruleid):
        """This method returns the compliance status for the named rule. This info
        is only valid after the rule has had the report or fix methods called.

        :param int ruleid:
        :return: compliant
        :rtype: bool

        """
        compliant = False
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                compliant = rule.iscompliant()
        return compliant

    def getruledetailedresults(self, ruleid):
        """This method returns the detailed results from the rule with a given
        rule id. Returned data will be a string.

        :param int ruleid:
        :return: detailedresults
        :rtype: str

        """
        detailedresults = ""
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                detailedresults = rule.getdetailedresults()
        return detailedresults

    def getcompletionpercentage(self):
        """This method returns the percentage of items on the to-do list
        completed. This only returns valid data when called while the whole
        rule stack is running.

        :return: percent
        :rtype: int (range = 0 - 100)
        
        """
        total = float(self.numrulesrunning)
        curr = float(self.numrulescomplete)
        if self.environ.getdebugmode():
            print("Controller:getcompletionpercentage: Total: " + str(total))
            print("Controller:getcompletionpercentage: Current: " + str(curr))
        if curr == 0:
            percent = 0
        else:
            percent = int((curr / total) * 100)
        if self.environ.getdebugmode():
            print("Controller:getcompletionpercentage: Percent: " + str(percent))
        return percent

    def set_rule_detailedresults(self, ruleid, mode, result, msg):
        """update the specified rule's (ruleid) detailedresults with the msg from
        the caller; (used to bridge the observable gap between other classes and
        the running rule)

        :param ruleid:the rule number identifier
        :param mode:fix|report|undo
        :param result:(see rule.py formatDetailedResults())
        :param msg:message to update detailedresults with

        """

        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                rule.formatDetailedResults(mode, result, msg)

    def getruleauditonly(self, ruleid):
        """This method returns the audit only status boolean
        from the rule with a given <ruleid>.

        :param ruleid: the rule number identifier
        :return: auditonly
        :rtype: bool


        """

        auditonly = False

        try:

            for rule in self.installedrules:
                if ruleid == rule.getrulenum():
                    auditonly = rule.getauditonly()

        except Exception as err:
            self.logger.log(LogPriority.DEBUG, str(err))
            return False
        return auditonly

    def displaylastrun(self):
        """Returns the contents of the log file by way of the logger object.


        :return: self.logger.displaylastrun()
        :rtype: str
        

        """
        return self.logger.displaylastrun()

    def tryacquirelock(self):
        """Try to set a lock file at /var/run/stonix_resources.pid. If the lock
        file already exists check to see if a stonix process with that PID is
        already running. If so exit with error else re-create lock file with
        our PID.

        """

        lockmessage = """
!WARNING! Another copy of STONIX appears to be running!
Running more than one copy of STONIX at a time may result in
unintended behavior! If STONIX is not running remove the file
/var/run/stonix.pid and re-launch STONIX.
ABORTING EXECUTION!"""

        if not self.euid == 0:
            # only grab a lock file for privileged use.
            return

        if os.path.exists(self.lockfile):
            rw_lockfile = open(self.lockfile, 'r+')
            lockpid = rw_lockfile.readline()
            lockpid = lockpid.strip()
            self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'Found lock for PID: ' + lockpid])
            try:
                if int(lockpid) == os.getpid():
                    # PID is the same, reuse PID file
                    return
            except (TypeError, ValueError):
                self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'Could not coerce PID to INT: ' + lockpid])

            if self.environ.getosfamily() == 'freebsd':
                command = '/bin/ps -aux'
            elif self.environ.getosfamily() == 'solaris':
                command = '/usr/bin/ps -ef'
            else:
                command = '/bin/ps -ef'

            self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'PS command is: ' + str(command)])

            pscom = subprocess.Popen(command, stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE,
                                     shell=True, close_fds=True)
            psout = pscom.stdout.readlines()
            for line in psout:
                line = str(line)
                if re.search('stonix', line):
                    splits = line.split()
                    pspid = splits[1]
                    self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'Checking PIDs: ' + lockpid + ' ' + pspid])
                    if pspid == lockpid:
                        self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'Matched PIDs: ' + lockpid + ' ' + pspid])
                        self.logger.log(LogPriority.CRITICAL, ['TryAcquireLock', lockmessage])
                        rw_lockfile.close()
                        sys.exit(2)

            self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'Truncating existing Lockfile'])
            rw_lockfile.truncate(0)
            rw_lockfile.write(str(os.getpid()))
            rw_lockfile.close()
        else:
            self.logger.log(LogPriority.DEBUG, ['TryAcquireLock', 'Creating new Lockfile'])
            rw_lockfile = open(self.lockfile, 'w')
            rw_lockfile.write(str(os.getpid()))
            rw_lockfile.close()

    def safetycheck(self):
        """Check that the installation of STONIX is safe from a security
        perspective. All files must only be writable by root.

        :return: safe
        :rtype: bool

        """

        safe = True

        if not self.permissions_check():
            safe = False

        return safe

    def permissions_check(self):
        """

        :return:
        """

        perms_ok = True
        group_writable = []
        world_writable = []

        installation_dirs = ["/usr/bin/stonix_resources"]
        installation_files = ["/etc/stonix.conf"]

        # build installation files list
        for d in installation_dirs:
            if os.path.isdir(d):
                files = os.listdir(d)
                for f in files:
                    if re.search(".py", f, re.I):
                        installation_files.append(d + "/" + f)

        # check installation files permissions
        for f in installation_files:
            if os.path.isfile(f):
                statinfo = os.stat(f)
                if bool(statinfo.st_mode & stat.S_IWGRP):
                    perms_ok = False
                    group_writable.append(f)
                elif bool(statinfo.st_mode & stat.S_IWOTH):
                    perms_ok = False
                    world_writable.append(f)

        self.logger.log(LogPriority.DEBUG, "The following STONIX files are group writable:\n" + "\n".join(group_writable))
        self.logger.log(LogPriority.DEBUG, "The following STONIX files are world writable:\n" + "\n".join(world_writable))

        if not perms_ok:
            self.logger.log(LogPriority.DEBUG, "STONIX files should only be writable by root!")

        return perms_ok

    def releaselock(self):
        """Cleans up the stonix lock file in the event of normal program
        exit.

        """

        self.logger.log(LogPriority.DEBUG, "Cleaning up STONIX lock file")

        if os.path.isfile(self.lockfile):
            if self.euid == 0:
                os.remove(self.lockfile)
            else:
                self.logger.log(LogPriority.DEBUG, "STONIX running as unprivileged user. Cannot remove lock file")
        else:
            self.logger.log(LogPriority.DEBUG, "No STONIX lock file exists to remove")

    def processargs(self):
        """This method calls the prog_args instance to process the command line
        args and then jumps to the appropriate execution mode.

        """
        self.environ.setverbosemode(self.prog_args.get_verbose())
        self.environ.setdebugmode(self.prog_args.get_debug())
        self.fix = self.prog_args.get_fix()
        self.report = self.prog_args.get_report()
        self.undo = self.prog_args.get_rollback()
        self.environ.setinstallmode(self.prog_args.get_install())
        self.pcf = self.prog_args.getPrintConfigFull()
        self.pcs = self.prog_args.getPrintConfigSimple()

        if self.prog_args.get_rollback():
            # rollback()
            pass

        if not re.match("^\s*$", self.prog_args.get_module()):
            runrule = self.prog_args.get_module()
            breakIndex = runrule.find(",")
            if breakIndex > 0:
                rulelist = []
                done = False
                while not done:
                    rulelist.append(runrule[0:breakIndex])
                    if len(runrule) > breakIndex:
                        runrule = runrule[breakIndex+1:]
                        breakIndex = runrule.find(",")
                        if breakIndex > 0:
                            continue
                        else:
                            rulelist.append(runrule)
                            done = True
                    else:
                        done = True
                self.runrule = rulelist
            else:
                self.runrule = runrule

        if self.prog_args.get_gui():
            self.mode = 'gui'

            # uiinstance = view.View(uimode)

        if self.prog_args.get_cli():
            self.mode = 'cli'

        if self.pcf or self.pcs:
            self.mode = 'cli'

    def setuptesting(self):
        """this method is called when the environment object determins that the
        controller is in test mode - e.g. running from a unittest.

        """
        self.environ.setverbosemode(True)
        self.environ.setdebugmode(True)
        self.fix = False
        self.report = False
        self.undo = False
        self.environ.setinstallmode(False)
        self.runrule = ""
        self.mode = 'test'

    def __listrules(self):
        """
        Private method that prints the list of currently installed and
        applicable rules. This is a part of the STONIX CLI user interface and
        is needed for users to be able to list rules available to run in module
        mode. The program will exit after this method is complete.

        """
        rulelist = []
        for rule in self.installedrules:
            rulenum = rule.getrulenum()
            rulename = rule.getrulename()
            rulestring = rulename + ' (' + str(rulenum) + ')'
            rulelist.append(rulestring)
        rulelist.sort(key=str.lower)
        print("STONIX rules which apply to this platform:")
        for rule in rulelist:
            print(rule)
        try:
            self.logger.closereports()
        except:
            pass
        self.releaselock()

    def __clirun(self):
        """
        This private method performs a cli run based on the passed flags.

        """

        self.logger.log(LogPriority.DEBUG, "Running STONIX in command line mode")
        myui = Cli(self.environ)

        # self.logger.register_listener(myui)
        self.register_listener(myui)
        if not self.runrule:
            self.logger.log(LogPriority.DEBUG, 'Running all enabled rules')
            if self.fix:
                self.logger.log(LogPriority.DEBUG, 'Mode is Fix')
                self.hardensystem()
                self.logger.closereports()
            if self.report:
                self.logger.log(LogPriority.DEBUG, 'Mode is Report')
                self.auditsystem()
                self.logger.postreport()
            if self.undo:
                self.logger.log(LogPriority.DEBUG, 'Mode is Undo')
                self.undochangessystem()
                self.logger.closereports()
            if self.pcf:
                self.logger.log(LogPriority.DEBUG, 'Generating Full config file')
                self.regenerateconfig(False)
                self.logger.closereports()
            if self.pcs:
                self.logger.log(LogPriority.DEBUG, 'Generating Simple config file')
                self.regenerateconfig(True)
                self.logger.closereports()
            elif True not in [self.fix, self.report, self.undo, self.pcf, self.pcs]:
                self.logger.log(LogPriority.INFO, 'No action specified. Please check command syntax')
                self.logger.closereports()

        elif isinstance(self.runrule, list):
            self.logger.log(LogPriority.DEBUG, 'Running rules: ' + ", ".join(self.runrule))
            for rule in self.runrule:
                self.logger.log(LogPriority.DEBUG, 'Entering single rule run for ' + rule)
                ruleid = self.getrulenumbyname(rule)
                self.logger.log(LogPriority.DEBUG, 'Rule ID number ' + str(ruleid))
                if self.fix:
                    self.logger.log(LogPriority.DEBUG, 'Mode is Fix')
                    self.runruleharden(ruleid)
                    self.logger.closereports()
                if self.report:
                    self.logger.log(LogPriority.DEBUG, 'Mode is Report')
                    self.runruleaudit(ruleid)
                    self.logger.closereports()
                if self.undo:
                    self.logger.log(LogPriority.DEBUG, 'Mode is Undo')
                    self.undorule(ruleid)
                    self.logger.closereports()
                if True not in [self.fix, self.report, self.undo]:
                    self.logger.log(LogPriority.INFO, 'No action specified. Please pass the -r, -f, or -X flag')
                self.logger.closereports()
        else:
            self.logger.log(LogPriority.DEBUG, 'Entering single rule run ' + self.runrule)
            ruleid = self.getrulenumbyname(self.runrule)
            self.logger.log(LogPriority.DEBUG, 'Rule ID number ' + str(ruleid))
            if self.fix:
                self.logger.log(LogPriority.DEBUG, 'Mode is Fix')
                self.runruleharden(ruleid)
                self.logger.closereports()
            if self.report:
                self.logger.log(LogPriority.DEBUG, 'Mode is Report')
                self.runruleaudit(ruleid)
                self.logger.closereports()
            if self.undo:
                self.logger.log(LogPriority.DEBUG, 'Mode is Undo')
                self.undorule(ruleid)
                self.logger.closereports()
            if True not in [self.fix, self.report, self.undo]:
                self.logger.log(LogPriority.INFO, 'No action specified. Please pass the -r, -f, or -X flag')
                self.logger.closereports()
        self.releaselock()

if __name__ == '__main__':
    STONIXAPP = Controller()
